/* LOAD IMPACT AB
 * 
 * Copyright 2017 Load Impact AB
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
 
using System;
using System.Diagnostics;
using System.Reflection;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows.Forms;
using Fiddler;
using MimeKit;

[assembly: Fiddler.RequiredVersion("2.4.0.0")]

namespace LoadImpact_Script_Export
{

    [ProfferFormat("k6 javascript", "Load Impact k6 javascript")]
    public class LI_Export : ISessionExporter
    {
        // The head contains the definition of the rnd function to generate a random int between min-max inclusive.

        private static string k6Head = @"// This script is generated by k6 exporter

// LOAD IMPACT AB
// 
// Copyright 2017 Load Impact AB
//
// Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License. You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions and limitations under the License.
//

import { group, check, sleep, taint} from ""k6"";
import http from ""k6/http"";
import { parseHTML} from ""k6/html"";

function rnd(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);

  return Math.floor(Math.random() * (max - min + 1)) + min;
}

";

// The footer contains the final sleep call which is a sensible default of 20-40 seconds sleep time to set the iteration pause

        private static string k6Foot = @"
    sleep(rnd(20, 40));
    return;
}";

        // Threshold for when sleep is auto generated between requests

        private static int sSleepThreshold = 2;

        private int getIndexOfText(ListView.ColumnHeaderCollection heads, string textkey)
        {
            int idx = -1;

            foreach (ColumnHeader head in heads)
            {
                if (head.Text == textkey)
                {
                    idx = head.Index;
                    return idx;
                }
            }

            // If we get here, it wasn't found

            return idx;
        }


        // Write multipart data
        private void addMultipart(MimeEntity mimeBody, 
                                  string strFilename,
                                  ref int iSequence,
                                  ref StringBuilder strbHead, 
                                  ref StringBuilder strbBody)
        {
            var multipart = mimeBody as Multipart;

            strbBody.AppendLine("`");
            foreach (MimePart part in multipart)
            {
                strbBody.AppendLine();
                strbBody.AppendLine();
                strbBody.AppendLine("--" + multipart.Boundary);

                foreach (Header head in part.Headers)
                {
                    strbBody.AppendLine(head.ToString());
                }
                strbBody.AppendLine();

                // if the part is multipart - recurse

                if (part.ContentType.MediaType.Contains("multipart"))
                {
                    addMultipart(part, strFilename, ref iSequence, ref strbHead, ref strbBody);
                }
                else
                {
                    StreamReader sr = new StreamReader(part.ContentObject.Stream);
                    string strBody = sr.ReadToEnd(); 

                    if ((part.ContentTransferEncoding == ContentEncoding.Binary) || (Regex.IsMatch(strBody, "[\x00-\x08\x0E-\x1F\x80-\xFF]")))
                    {
                        // It's binary
                        // Save binary part to file,
                        // load binary in script
                        // use binary in multipart

                        // Save as binary file and use binary content
                        // same location as Script output since that is allowed to be written
                        // Append open to header before function

                        string strCat = Path.GetDirectoryName(Path.GetFullPath(strFilename));

                        string strData = "bin" + iSequence;
                        string strOutfile = strCat + "\\" + strData + ".bin";
                        FileStream f = new FileStream(strOutfile, FileMode.OpenOrCreate, FileAccess.Write);

                        part.ContentObject.Stream.Position = 0;
                        part.ContentObject.Stream.CopyTo(f);
                        f.Close();

                        strbHead.AppendLine();
                        strbHead.AppendLine(strData + " = open(\"" + strData + ".bin\");");
                        strbHead.AppendLine();

                        strbBody.AppendLine("` + " + strData + " + `");

                        iSequence++;
                    }
                    else
                    {
                        // It's not binary, just write it.
                        // Make sure we escape all double quotes " since we use double quotes for strings in the script

                        strBody = strBody.Replace("\"", "\\\"");

                        strbBody.Append(strBody);
                    }
                }
            }
            strbBody.AppendLine();
            strbBody.Append("--" + multipart.Boundary + "--");
            strbBody.AppendLine("`");
        }

        public bool ExportSessions(string sFormat, 
                                   Session[] oSessions, 
                                   Dictionary<string, object> dictOptions,
                                   EventHandler<ProgressCallbackEventArgs> evtProgressNotifications)
        {
            bool bResult = false;

            // Private
            // List of groups

            bool inGroup = false;
            string strCurrentGroup = "";
            List<Session> liGroup = new List<Session>();

            // Determine if we already have a filename from the dictOptions collection
            string sFilename = null;
            if (null != dictOptions && dictOptions.ContainsKey("Filename"))
            {
                sFilename = dictOptions["Filename"] as string;
            }

            if (sFormat == "k6 javascript")
            {
                if (string.IsNullOrEmpty(sFilename)) sFilename = Fiddler.Utilities.ObtainSaveFilename("Export As " + sFormat, "k6 js Files (*.js)|*.js");
            }
            else
            {
                // something is seriously wrong
                return false;
            }

            if (String.IsNullOrEmpty(sFilename))
                return false;

            // Make sure we have the extended column every export
            // named "LI Group"
            // Requires you to have Fiddler Script extensions

            int iCol = getIndexOfText(oSessions[0].ViewItem.ListView.Columns, "LI Group");
            if (iCol == -1)
            {
                MessageBox.Show("You should include the FiddlerScript extension for the \"Li Group\" column", "Missing \"LI Group\" column");
                return false;
            }

            try
            {
                StringBuilder strbHead = new StringBuilder();
                StringBuilder strbBody = new StringBuilder();
                StringBuilder strbFoot = new StringBuilder();

                StreamWriter swOutput = new StreamWriter(sFilename, false, Encoding.UTF8);

                int iCount = 0;
                int iMax = oSessions.Length;
                Fiddler.HTTPRequestHeaders headers;
                string strContentType = "";
                bool fSkip = false;
                int iBinarySequence = 1;
                DateTime dtPrevious = oSessions.First<Session>().Timers.ClientDoneRequest;

                #region WriteHead
                strbHead.Append(k6Head);
                strbHead.AppendLine();
                #endregion WriteHead


                // Start the body with the function header

                strbBody.Append(@"
// Use a top-level function wrapper to allow us to return from it. If you don't need to
// return from your script at any point, you can skip the wrapper - VU scopes are isolated.
export default function() {

"
                    );

                #region WriteEachSession
                foreach (Session oS in oSessions)
                {
                    iCount++;

                    // We just want requests, not connections and stuff
                    if (!oS.isTunnel)
                    {
                        // If the response is a redirect, skip the next request
                        if (fSkip)
                        {
                            fSkip = Utilities.IsRedirectStatus(oS.responseCode);
                            continue;
                        }
                        else
                        {
                            fSkip = Utilities.IsRedirectStatus(oS.responseCode);
                        }

                        // Find out if we are starting a new group, finishing a group or are in a group

                        string strVal = oS.ViewItem.SubItems[iCol].Text;

                        if ((!inGroup) && (strVal.Length > 0))
                        {
                            // NEW group from NO group, write the header

                            strCurrentGroup = strVal;
                            strbBody.AppendLine("\tgroup (\"" + strCurrentGroup + "\", function () {");

                            inGroup = true;
                        }
                        else if ((inGroup) && (strVal.Length > 0) && (strVal != strCurrentGroup))
                        {
                            // NEW group from OLD group
                            // write footer to end old and header for new

                            strbBody.AppendLine("\t});");
                            strbBody.AppendLine();

                            inGroup = true;
                            strCurrentGroup = strVal;
                            strbBody.AppendLine("\tgroup (\"" + strCurrentGroup + "\", function () {");
                        }
                        else if ((inGroup) && (strVal.Length == 0))
                        {
                            // NO group from OLD group
                            // write footer to close group

                            strbBody.AppendLine("\t});");
                            strbBody.AppendLine();
                            inGroup = false;
                            strCurrentGroup = strVal;
                        }


                        // Figure out time between last request and this request
                        // If > threshold -> insert sleep time
                        // BUT we should check if we just finished/started a group - then it should be between groups...

                        TimeSpan dtDiff = oS.Timers.ClientBeginRequest - dtPrevious;

                        if (dtDiff >= TimeSpan.FromSeconds(sSleepThreshold))
                        {
                            strbBody.AppendLine("\nsleep(" + dtDiff.Seconds + ");\n");
                        }
                        dtPrevious = oS.Timers.ClientDoneRequest;

                        // Always print request plain to file

                        strbBody.Append("\thttp." + oS.RequestMethod.ToLower() + "(\"" + oS.fullUrl + "\"");


                        // find out if we have a content-type
                        headers = oS.RequestHeaders;
                        if (headers.Exists("Content-Type"))
                        {
                            strContentType = headers["Content-Type"];
                        }
                        else
                        {
                            strContentType = "";
                        }

                        if (oS.RequestBody.Length > 0)
                        {
                            // handle different types of data

                            // Is it multipart?
                            // Or is it binary?
                            // /[\x00-\x08\x0E-\x1F\x80-\xFF]

                            if (strContentType.Contains("multipart"))
                            {
                                strbBody.Append(", ");

                                // Need to write all the multipart stuff to a variable and use it

                                addMultipart(MimeEntity.Load(ContentType.Parse(oS.RequestHeaders["Content-Type"]), new MemoryStream(System.Text.Encoding.UTF8.GetBytes(oS.GetRequestBodyAsString()))),
                                             sFilename,
                                             ref iBinarySequence,         
                                             ref strbHead, 
                                             ref strbBody);


                                // Make sure we escape all double quotes " since we use double quotes for strings in the script

                                string strCT = headers["Content-Type"];
                                strCT = strCT.Replace("\"", "\\\"");

                                strbBody.Append(", { headers: { \"Content-Type\" : \"" + strCT + "\"} }");
                            }
                            else if (Regex.IsMatch(System.Text.Encoding.UTF8.GetString(oS.RequestBody), "[\x00-\x08\x0E-\x1F\x80-\xFF]") || Utilities.IsBinaryMIME(oS.RequestHeaders["Content-Type"]))
                            {
                                // Save as binary file and use binary content
                                // same location as Script output since that is allowed to be written
                                // Append open to header before function

                                string strCat = Path.GetDirectoryName(Path.GetFullPath(sFilename));

                                string strData = "bin" + iBinarySequence;
                                string strFilename = strCat + "\\" + strData + ".bin";
                                FileStream f = new FileStream(strFilename, FileMode.OpenOrCreate, FileAccess.Write);
                                f.Write(oS.RequestBody, 0, oS.RequestBody.Length);
                                f.Close();

                                strbHead.AppendLine();
                                strbHead.AppendLine(strData + " = open(\"" + strData + ".bin\");");
                                strbHead.AppendLine();
                                strbBody.Append(", " + strData);
                                iBinarySequence++;
                            }
                            else
                            {
                                // Is text
                                // Output BODY for POST

                                string strBody = oS.GetRequestBodyAsString();
                                //System.Text.Encoding.UTF8.GetString(oS.RequestBody);

                                // Make sure we escape all double quotes " since we use double quotes for strings in the script

                                strBody = strBody.Replace("\"", "\\\"");

                                strbBody.Append(", \"" + strBody + "\"");
                                if (headers.Exists("Content-Type"))
                                {
                                    strbBody.Append(", { headers: { \"Content-Type\" : \"" + headers["Content-Type"] + "\"} }");
                                }
                            }
                        }


                        if ((inGroup) && (oS == oSessions.Last()))
                        {
                            // IF last request GROUP completed

                            strbBody.AppendLine("\t});");
                            strbBody.AppendLine();
                            inGroup = false;
                        }
                        else
                        {
                            strbBody.Append(");");
                            strbBody.AppendLine();
                        }

                    } // endif tunnel

                    if (null != evtProgressNotifications)
                    {
                        evtProgressNotifications(null, new ProgressCallbackEventArgs(0, "" ));
                        ProgressCallbackEventArgs PCEA = new ProgressCallbackEventArgs((iCount / (float)iMax), "wrote " + iCount.ToString() + " records.");
                        evtProgressNotifications(null, PCEA);
                        if (PCEA.Cancel)
                        {
                            swOutput.Close();
                            return false;
                        }
                    }
                } // endfor

                #endregion WriteEachSession

                #region WriteFoot
                strbFoot.Append(k6Foot);
                strbFoot.AppendLine();
                #endregion WriteFoot

                #region WriteToFile
                swOutput.WriteLine(strbHead);
                swOutput.WriteLine(strbBody);
                swOutput.WriteLine(strbFoot);
                swOutput.Close();
                bResult = true;
                #endregion WriteToFile
            }
            catch (Exception eX)
            {
                MessageBox.Show(eX.Message, "Failed to export");
                bResult = false;
            }

            return bResult;
        }

   public void Dispose()
   {
   }

  }

}

