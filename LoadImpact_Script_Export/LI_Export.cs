/* LOAD IMPACT AB
 * 
 * Copyright 2017 Load Impact AB
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
 
using System;
using System.Diagnostics;
using System.Reflection;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows.Forms;
using Fiddler;
using MimeKit;

[assembly: Fiddler.RequiredVersion("2.4.0.0")]

namespace LoadImpact_Script_Export
{

    [ProfferFormat("k6 javascript", "Load Impact k6 javascript")]
    public class LI_Export : ISessionExporter
    {
        // The head contains the definition of the rnd function to generate a random int between min-max inclusive.

        private static string k6Head = @"// This script is generated by k6 exporter

// LOAD IMPACT AB
// 
// Copyright 2017 Load Impact AB
//
// Licensed under the Apache License, Version 2.0 (the ""License""); you may not use this file except in compliance with the License. You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an ""AS IS"" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions and limitations under the License.
//

import { group, check, sleep, taint} from ""k6"";
import http from ""k6/http"";
import { parseHTML} from ""k6/html"";

function rnd(min, max) {
  min = Math.ceil(min);
  max = Math.floor(max);

  return Math.floor(Math.random() * (max - min + 1)) + min;
}

";

// The footer contains the final sleep call which is a sensible default of 20-40 seconds sleep time to set the iteration pause

        private static string k6Foot = @"
    sleep(rnd(20, 40));
    return;
}";

        // Threshold for when sleep is auto generated between requests
        // Threshold for automatically generating batches (i.e. max diff of request starting time to be included in a batch)

        private static int sSleepThreshold = 2;

        // Threshold for automatically generating batches (i.e. max diff of request starting time to be included in a batch)

        private int getIndexOfText(ListView.ColumnHeaderCollection heads, string textkey)
        {
            int idx = -1;

            foreach (ColumnHeader head in heads)
            {
                if (head.Text == textkey)
                {
                    idx = head.Index;
                    return idx;
                }
            }

            // If we get here, it wasn't found

            return idx;
        }


        // Write multipart data
        private void addMultipart(MimeEntity mimeBody, 
                                  string strFilename,
                                  ref int iSequence,
                                  ref StringBuilder strbHead, 
                                  ref StringBuilder strbBody)
        {
            var multipart = mimeBody as Multipart;

            foreach (MimePart part in multipart)
            {
                strbBody.AppendLine();
                strbBody.AppendLine();
                strbBody.AppendLine("--" + multipart.Boundary);

                foreach (Header head in part.Headers)
                {
                    strbBody.AppendLine(head.ToString());
                }
                strbBody.AppendLine();

                // if the part is multipart - recurse

                if (part.ContentType.MediaType.Contains("multipart"))
                {
                    addMultipart(part, strFilename, ref iSequence, ref strbHead, ref strbBody);
                }
                else
                {
                    StreamReader sr = new StreamReader(part.ContentObject.Stream);
                    string strBody = sr.ReadToEnd(); 

                    if ((part.ContentTransferEncoding == ContentEncoding.Binary) || (Regex.IsMatch(strBody, "[\x00-\x08\x0E-\x1F\x80-\xFF]")))
                    {
                        // It's binary
                        // Save binary part to file,
                        // load binary in script
                        // use binary in multipart

                        // Save as binary file and use binary content
                        // same location as Script output since that is allowed to be written
                        // Append open to header before function

                        string strCat = Path.GetDirectoryName(Path.GetFullPath(strFilename));

                        string strData = "bin" + iSequence;
                        string strOutfile = strCat + "\\" + strData + ".bin";
                        FileStream f = new FileStream(strOutfile, FileMode.OpenOrCreate, FileAccess.Write);

                        part.ContentObject.Stream.Position = 0;
                        part.ContentObject.Stream.CopyTo(f);
                        f.Close();

                        strbHead.AppendLine(strData + " = open(\"" + strData + ".bin\");");
                        strbHead.AppendLine();

                        strbBody.AppendLine("` + " + strData + " + `");

                        iSequence++;
                    }
                    else
                    {
                        // It's not binary, just write it.
                        // Make sure we escape all double quotes " since we use double quotes for strings in the script

                        strBody = strBody.Replace("\"", "\\\"");

                        strbBody.Append(strBody);
                    }
                }
            }
            strbBody.AppendLine();
            strbBody.Append("--" + multipart.Boundary + "--");
        }


        // Process POST data

        private void processPOST(Session oS, 
                                 ref StringBuilder strbBody,
                                 ref StringBuilder strbHead,
                                 ref int iBinarySequence,
                                 string sFilename)
        {
            HTTPRequestHeaders headers = oS.RequestHeaders;
            string strContentType = "";

            // find out if we have a content-type

            if (headers.Exists("Content-Type"))
            {
                strContentType = headers["Content-Type"];
            }
            else
            {
                strContentType = "";
            }

            if (oS.RequestBody.Length > 0)
            {
                // handle different types of data

                // Is it multipart?
                // Or is it binary?
                // /[\x00-\x08\x0E-\x1F\x80-\xFF]

                if (strContentType.Contains("multipart"))
                {
                    strbBody.AppendLine(", \"body\" : `");

                    // Need to write all the multipart stuff to a variable and use it

                    addMultipart(MimeEntity.Load(ContentType.Parse(oS.RequestHeaders["Content-Type"]), new MemoryStream(System.Text.Encoding.UTF8.GetBytes(oS.GetRequestBodyAsString()))),
                                 sFilename,
                                 ref iBinarySequence,
                                 ref strbHead,
                                 ref strbBody);

                    strbBody.AppendLine("`");

                    // Make sure we escape all double quotes " since we use double quotes for strings in the script

                    string strCT = headers["Content-Type"];
                    strCT = strCT.Replace("\"", "\\\"");

                    strbBody.Append(", \"params\" : { headers: { \"Content-Type\" : \"" + strCT + "\"} }");
                }
                else if (Regex.IsMatch(System.Text.Encoding.UTF8.GetString(oS.RequestBody), "[\x00-\x08\x0E-\x1F\x80-\xFF]") || Utilities.IsBinaryMIME(oS.RequestHeaders["Content-Type"]))
                {
                    // Save as binary file and use binary content
                    // same location as Script output since that is allowed to be written
                    // Append open to header before function

                    string strCat = Path.GetDirectoryName(Path.GetFullPath(sFilename));

                    string strData = "bin" + iBinarySequence;
                    string strFilename = strCat + "\\" + strData + ".bin";
                    FileStream f = new FileStream(strFilename, FileMode.OpenOrCreate, FileAccess.Write);
                    f.Write(oS.RequestBody, 0, oS.RequestBody.Length);
                    f.Close();

                    strbHead.AppendLine(strData + " = open(\"" + strData + ".bin\");");
                    strbHead.AppendLine();
                    strbBody.Append(", \"body\" : " + strData);
                    iBinarySequence++;

                    if (headers.Exists("Content-Type"))
                    {
                        strbBody.Append(", \"params\" : { headers: { \"Content-Type\" : \"" + headers["Content-Type"] + "\"} }");
                    }

                }
                else
                {
                    // Is text
                    // Output BODY for POST

                    string strBody = oS.GetRequestBodyAsString();
                    //System.Text.Encoding.UTF8.GetString(oS.RequestBody);

                    // Make sure we escape all double quotes " since we use double quotes for strings in the script

                    strBody = strBody.Replace("\"", "\\\"");

                    strbBody.Append(", \"body\" :  \"" + strBody + "\"");
                    if (headers.Exists("Content-Type"))
                    {
                        strbBody.Append(", \"params\" : { headers: { \"Content-Type\" : \"" + headers["Content-Type"] + "\"} }");
                    }
                }
            }
        }

        // Terminate batches actually writes them
        private void terminateBatches(Dictionary<string, List<Session>> dictBatches, 
                                      ref StringBuilder strbBody,
                                      ref StringBuilder strbHead,
                                      ref int iBinarySequence,
                                      string sFilename)
        {
            foreach (KeyValuePair<string, List<Session>> kvp in dictBatches)
            {

                // Start batch

                strbBody.AppendLine("\thttp.batch([");

                foreach (Session oS in kvp.Value)
                {
                    string strRequest = "";

                    // If I am not the first request, I am one in a list of several

                    if (oS != kvp.Value.First())
                    {
                        strbBody.AppendLine(",");
                    }

                    // Request

                    strRequest = "\t\t{\"method\" : \"" + oS.RequestMethod.ToUpper() + "\", \"url\" : \"" + oS.fullUrl + "\"";

                    strbBody.Append(strRequest);

                    processPOST(oS, 
                                ref strbBody,
                                ref strbHead,
                                ref iBinarySequence,
                                sFilename);

                    strbBody.Append("}");

                }

                // End batch

                strbBody.AppendLine();
                strbBody.AppendLine("\t]);");
            }

        }

        public bool ExportSessions(string sFormat, 
                                   Session[] oSessions, 
                                   Dictionary<string, object> dictOptions,
                                   EventHandler<ProgressCallbackEventArgs> evtProgressNotifications)
        {
            bool bResult = false;

            // Private
            // List of groups

            bool inGroup = false;
            string strCurrentGroup = "";
            List<Session> liGroup = new List<Session>();

            // Determine if we already have a filename from the dictOptions collection
            string sFilename = null;
            if (null != dictOptions && dictOptions.ContainsKey("Filename"))
            {
                sFilename = dictOptions["Filename"] as string;
            }

            if (sFormat == "k6 javascript")
            {
                if (string.IsNullOrEmpty(sFilename)) sFilename = Fiddler.Utilities.ObtainSaveFilename("Export As " + sFormat, "k6 js Files (*.js)|*.js");
            }
            else
            {
                // something is seriously wrong
                return false;
            }

            if (String.IsNullOrEmpty(sFilename))
                return false;

            // Make sure we have the extended column every export
            // named "LI Group"
            // Requires you to have Fiddler Script extensions

            int iCol = getIndexOfText(oSessions[0].ViewItem.ListView.Columns, "LI Group");
            if (iCol == -1)
            {
                MessageBox.Show("You should include the FiddlerScript extension for the \"Li Group\" column", "Missing \"LI Group\" column");
                return false;
            }

            try
            {
                StringBuilder strbHead = new StringBuilder();
                StringBuilder strbBody = new StringBuilder();
                StringBuilder strbFoot = new StringBuilder();

                StreamWriter swOutput = new StreamWriter(sFilename, false, Encoding.UTF8);

                int iCount = 0;
                int iMax = oSessions.Length;
                Fiddler.HTTPRequestHeaders headers;
                bool fSkip = false;
                int iBinarySequence = 1;
                DateTime dtPrevious = oSessions.First<Session>().Timers.ClientDoneResponse;
                Dictionary<string, List<Session>> bg = null;

                #region WriteHead
                strbHead.Append(k6Head);
                strbHead.AppendLine();
                #endregion WriteHead


                // Start the body with the function header

                strbBody.Append(@"
// Use a top-level function wrapper to allow us to return from it. If you don't need to
// return from your script at any point, you can skip the wrapper - VU scopes are isolated.
export default function() {

"
                    );

                #region WriteEachSession

                foreach (Session oS in oSessions)
                {
                    iCount++;

                    // We just want requests, not connections and stuff
                    if (!oS.isTunnel)
                    {
                        // If the response is a redirect, skip the next request
                        if (fSkip)
                        {
                            fSkip = Utilities.IsRedirectStatus(oS.responseCode);
                            continue;
                        }
                        else
                        {
                            fSkip = Utilities.IsRedirectStatus(oS.responseCode);
                        }

                        // Figure out time between last request and this request
                        // If > threshold -> insert sleep time

                        TimeSpan dtDiff = oS.Timers.ClientBeginRequest - dtPrevious;
                        dtPrevious = oS.Timers.ClientDoneResponse;

                        // Find out if we are starting a new group, finishing a group or are in a group

                        string strVal = oS.ViewItem.SubItems[iCol].Text;

                        if ((!inGroup) && (strVal.Length > 0))
                        {
                            // NEW group from NO group, write the header

                            // Terminate batches - except first request since it will not be in a batch

                            if (bg != null)
                            {
                                terminateBatches(bg, ref strbBody, ref strbHead, ref iBinarySequence, sFilename);

                                // Dispose manually

                                bg.Clear();
                                bg = null;
                            }

                            // Insert sleep _before_ if needed

                            if (dtDiff >= TimeSpan.FromSeconds(sSleepThreshold))
                            {
                                strbBody.AppendLine("\n\tsleep(" + dtDiff.Seconds + ");\n");
                            }

                            strCurrentGroup = strVal;
                            strbBody.AppendLine("\tgroup (\"" + strCurrentGroup + "\", function () {");

                            // START NEW BATCH COLLECTION

                            bg = new Dictionary<string, List<Session>>();

                            // Set flag

                            inGroup = true;
                        }
                        else if ((inGroup) && (strVal.Length > 0) && (strVal != strCurrentGroup))
                        {
                            // NEW group from OLD group
                            // write footer to end old and header for new

                            // Terminate batches

                            terminateBatches(bg, ref strbBody, ref strbHead, ref iBinarySequence, sFilename);

                            // Dispose manually

                            bg.Clear();
                            bg = null;


                            strbBody.AppendLine("\t});");
                            strbBody.AppendLine();

                            // Insert sleep _between_ groups
                            if (dtDiff >= TimeSpan.FromSeconds(sSleepThreshold))
                            {
                                strbBody.AppendLine("\n\tsleep(" + dtDiff.Seconds + ");\n");
                            }

                            inGroup = true;
                            strCurrentGroup = strVal;
                            strbBody.AppendLine("\tgroup (\"" + strCurrentGroup + "\", function () {");

                            // START NEW BATCH COLLECTION

                            bg = new Dictionary<string, List<Session>>();
                        }
                        else if ((inGroup) && (strVal.Length == 0))
                        {
                            // NO group from OLD group
                            // write footer to close group

                            // Terminate batches

                            terminateBatches(bg, ref strbBody, ref strbHead, ref iBinarySequence, sFilename);

                            // Dispose manually

                            bg.Clear();
                            bg = null;

                            strbBody.AppendLine("\t});");
                            strbBody.AppendLine();
                            inGroup = false;
                            strCurrentGroup = strVal;

                            // If sleep applies after last step in group

                            if (dtDiff >= TimeSpan.FromSeconds(sSleepThreshold))
                            {
                                strbBody.AppendLine("\n\tsleep(" + dtDiff.Seconds + ");\n");
                            }

                            // START NEW BATCH COLLECTION

                            bg = new Dictionary<string, List<Session>>();
                        }
                        else
                        {
                            // NO group from NO group or IN GROUP STAYING IN GROUP
                            // sleep might apply

                            // Check if batch shall be terminated by timespan, same as sleep

                            if (dtDiff >= TimeSpan.FromSeconds(sSleepThreshold))
                            {
                                // Terminate batches - except first request since it will not be in a batch

                                if (bg != null)
                                {
                                    terminateBatches(bg, ref strbBody, ref strbHead, ref iBinarySequence, sFilename);

                                    // Dispose manually

                                    bg.Clear();
                                    bg = null;
                                }

                                strbBody.AppendLine("\n\tsleep(" + dtDiff.Seconds + ");\n");

                                // START NEW BATCH COLLECTION

                                bg = new Dictionary<string, List<Session>>();
                            }
                            else
                            {
                                if (bg == null)
                                {
                                    bg = new Dictionary<string, List<Session>>();
                                }
                            }
                        }


                        // If there is no referer header, set a __NO_REFERER referer

                        headers = oS.RequestHeaders;
                        string refKey = headers.Exists("Referer") ? headers["Referer"] : "__NO_REFERER";

                        if (!bg.ContainsKey(refKey))
                        {
                            bg[refKey] = new List<Session>();
                        }



                        // Add request to batch

                        bg[refKey].Add(oS);

                        if (oS == oSessions.Last())
                        {
                            // Terminate batches - except first request since it will not be in a batch

                            terminateBatches(bg, ref strbBody, ref strbHead, ref iBinarySequence, sFilename);

                            // Dispose manually

                            bg.Clear();
                            bg = null;

                            if (inGroup)
                            {
                                // IF last request GROUP completed

                                strbBody.AppendLine("\t});");
                                strbBody.AppendLine();
                                inGroup = false;
                            }
                        }

                        /*
                        else
                        { // end of line
                            strbBody.Append(");");
                            strbBody.AppendLine();
                        }
                        */

                    } // endif tunnel

                    if (null != evtProgressNotifications)
                    {
                        evtProgressNotifications(null, new ProgressCallbackEventArgs(0, "" ));
                        ProgressCallbackEventArgs PCEA = new ProgressCallbackEventArgs((iCount / (float)iMax), "wrote " + iCount.ToString() + " records.");
                        evtProgressNotifications(null, PCEA);
                        if (PCEA.Cancel)
                        {
                            swOutput.Close();
                            return false;
                        }
                    }
                } // endfor

                #endregion WriteEachSession

                #region WriteFoot
                strbFoot.Append(k6Foot);
                strbFoot.AppendLine();
                #endregion WriteFoot

                #region WriteToFile
                swOutput.WriteLine(strbHead);
                swOutput.WriteLine(strbBody);
                swOutput.WriteLine(strbFoot);
                swOutput.Close();
                bResult = true;
                #endregion WriteToFile
            }
            catch (Exception eX)
            {
                MessageBox.Show(eX.Message, "Failed to export");
                bResult = false;
            }

            return bResult;
        }

   public void Dispose()
   {
   }

  }

}

