/* LOAD IMPACT AB
 * 
 * Copyright 2017 Load Impact AB
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
 
using System;
using System.Diagnostics;
using System.Reflection;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows.Forms;
using Fiddler;

[assembly: Fiddler.RequiredVersion("2.4.0.0")]

namespace LoadImpact_Script_Export
{

    [ProfferFormat("k6 javascript", "Load Impact k6 javascript")]
    public class LI_Export : ISessionExporter
    {
        private static string k6Head = @"// This script is generated by k6 exporter

// LOAD IMPACT AB
// 
// Copyright 2017 Load Impact AB
//
// Licensed under the Apache License, Version 2.0 (the 'License'); you may not use this file except in compliance with the License. You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an 'AS IS' BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.See the License for the specific language governing permissions and limitations under the License.
//

import { group, check, sleep, taint} from ""k6"";
import http from ""k6/http"";
import { parseHTML} from ""k6/html"";

// Use a top-level function wrapper to allow us to return from it. If you don't need to
// return from your script at any point, you can skip the wrapper - VU scopes are isolated.
export default function() {";


        private static string k6Foot = @"return;
}";

        private int getIndexOfText(ListView.ColumnHeaderCollection heads, string textkey)
        {
            int idx = -1;

            foreach (ColumnHeader head in heads)
            {
                if (head.Text == textkey)
                {
                    idx = head.Index;
                    break;
                }
            }

            return idx;
        }

        public bool ExportSessions(string sFormat, 
                                   Session[] oSessions, 
                                   Dictionary<string, object> dictOptions,
                                   EventHandler<ProgressCallbackEventArgs> evtProgressNotifications)
        {
            bool bResult = false;

            // Private
            // List of groups

            bool inGroup = false;
            string strCurrentGroup = "";
            List<Session> liGroup = new List<Session>();

            // Determine if we already have a filename from the dictOptions collection
            string sFilename = null;
            if (null != dictOptions && dictOptions.ContainsKey("Filename"))
            {
                sFilename = dictOptions["Filename"] as string;
            }

            if (sFormat == "k6 javascript")
            {
                if (string.IsNullOrEmpty(sFilename)) sFilename = Fiddler.Utilities.ObtainSaveFilename("Export As " + sFormat, "k6 js Files (*.js)|*.js");
            }
            else
            {
                // something is seriously wrong
                return false;
            }

            if (String.IsNullOrEmpty(sFilename))
                return false;

            // Make sure we have the extended column every export
            // named "LI Group"
            // Requires you to have Fiddler Script extensions

            int iCol = getIndexOfText(oSessions[0].ViewItem.ListView.Columns, "LI Group");
            if (iCol == -1)
            {
                MessageBox.Show("You should include the FiddlerScript extension for the \"Li Group\" column", "Missing \"LI Group\" column");
                return false;
            }

            try
            {
                StreamWriter swOutput = new StreamWriter(sFilename, false, Encoding.UTF8);
                int iCount = 0;
                int iMax = oSessions.Length;
                Fiddler.HTTPRequestHeaders headers;
                string strContentType = "";
                bool fSkip = false;

                #region WriteHead
                swOutput.Write(k6Head);
                swOutput.WriteLine();
                #endregion WriteHead

                #region WriteEachSession
                foreach (Session oS in oSessions)
                {
                    iCount++;

                    // We just want requests, not connections and stuff
                    if (!oS.isTunnel)
                    {
                        // If the response is a redirect, skip the next request
                        if (fSkip)
                        {
                            fSkip = Utilities.IsRedirectStatus(oS.responseCode);
                            continue;
                        }
                        else
                        {
                            fSkip = Utilities.IsRedirectStatus(oS.responseCode);
                        }

                        // Find out if we are starting a new group, finishing a group or are in a group

                        string strVal = oS.ViewItem.SubItems[iCol].Text;

                        if ((!inGroup) && (strVal.Length > 0))
                        {
                            // NEW group from NO group, write the header

                            strCurrentGroup = strVal;
                            swOutput.WriteLine("\tgroup (\"" + strCurrentGroup + "\", function () {");

                            inGroup = true;
                        }
                        else if ((inGroup) && (strVal.Length > 0) && (strVal != strCurrentGroup))
                        {
                            // NEW group from OLD group
                            // write footer to end old and header for new

                            swOutput.WriteLine("\t});");
                            swOutput.WriteLine();

                            inGroup = true;
                            strCurrentGroup = strVal;
                            swOutput.WriteLine("\tgroup (\"" + strCurrentGroup + "\", function () {");
                        }
                        else if ((inGroup) && (strVal.Length == 0))
                        {
                            // NO group from OLD group
                            // write footer to close group

                            swOutput.WriteLine("\t});");
                            swOutput.WriteLine();
                            inGroup = false;
                            strCurrentGroup = strVal;
                        }

                        // Always print request plain to file

                        swOutput.Write("\thttp." + oS.RequestMethod.ToLower() + "(\"" + oS.fullUrl + "\"");


                        // find out if we have a content-type
                        headers = oS.RequestHeaders;
                        if (headers.Exists("Content-Type"))
                        {
                            strContentType = headers["Content-Type"];
                        }
                        else
                        {
                            strContentType = "";
                        }

                        if (oS.RequestBody.Length > 0)
                        {
                            // handle different types of data

                            // Is it binary?
                            // /[\x00-\x08\x0E-\x1F\x80-\xFF]

                            if (Regex.IsMatch(System.Text.Encoding.UTF8.GetString(oS.RequestBody), "[\x00-\x08\x0E-\x1F\x80-\xFF]") || Utilities.IsBinaryMIME(oS.RequestHeaders["Content-Type"]))
                            {
                                // Is binary - encode
                                // Re-encode binary
                                // Output as BODY for POST

                                // TODO: When k6 can handle files - save as binary file and use binary content

                                string strBody = Convert.ToBase64String(oS.RequestBody).ToString();
                                swOutput.Write(", \"" + "binary body placeholder\"");
                                //swOutput.Write("\", \"" + strBody);
                            }
                            else
                            {
                                // Is text
                                // Output BODY for POST

                                string strBody = System.Text.Encoding.UTF8.GetString(oS.RequestBody);

                                // Make sure we escape all double quotes " since we use double quotes for strings in the script

                                strBody = strBody.Replace("\"", "\\\"");

                                swOutput.Write(", \"" + strBody + "\"");
                                if (headers.Exists("Content-Type"))
                                {
                                    swOutput.Write(", { headers: { \"Content-Type\" : \"" + headers["Content-Type"] + "\"} }");
                                }
                            }
                        }



                        if ((inGroup) && (oS == oSessions.Last()))
                        {
                            // IF last request GROUP completed

                            swOutput.WriteLine("\t});");
                            swOutput.WriteLine();
                            inGroup = false;
                        }
                        else
                        {
                            swOutput.Write(");");
                            swOutput.WriteLine();
                        }

                    } // endif tunnel

                    if (null != evtProgressNotifications)
                    {
                        evtProgressNotifications(null, new ProgressCallbackEventArgs(0, "" ));
                        ProgressCallbackEventArgs PCEA = new ProgressCallbackEventArgs((iCount / (float)iMax), "wrote " + iCount.ToString() + " records.");
                        evtProgressNotifications(null, PCEA);
                        if (PCEA.Cancel)
                        {
                            swOutput.Close();
                            return false;
                        }
                    }
                } // endfor

                #endregion WriteEachSession

                #region WriteFoot
                swOutput.Write(k6Foot);
                swOutput.WriteLine();
                #endregion WriteFoot

                swOutput.Close();
                bResult = true;
            }
            catch (Exception eX)
            {
                MessageBox.Show(eX.Message, "Failed to export");
                bResult = false;
            }

            return bResult;
        }

   public void Dispose()
   {
   }

  }

}

